# Interface Contracts

Interface contracts allow developers to express precisely their expectations of the users of their interface and the guarantees their interface provides.

The interface designer typically constructs contracts out of three kinds of elements:

1. A method _pre-condition_, i.e., a condition that must hold whenever someone calls a method.
   The condition may refer to the method arguments or the public fields and methods of the class.
   It is a responsibility of the caller to make sure the condition holds.
2. A method _post-condition_, i.e., a condition that is guaranteed to hold right after the method returns.
   The condition may refer to the method arguments, public fields and methods of the class (their value prior and after the call), and the method return value.
3. A class _invariant_, i.e., a condition that holds between method calls.
   You can think of the class invariant as a mandatory part of every pre- and post-condition of every method (except for the class constructor, in which case the object does not exist before the call).
   It is the implementation of the class that makes sure the invariant holds, by assuming it at the start of every method and ensuring at the end of every method.

(Note that the function signature is itself a kind of a contract:
It requires the arguments to be of specific types, and it guarantees a particular type for the return value.
Depending on the type system of your programming language, this contract can be quite powerful.)

## Cofoja

The [Cofoja](https://github.com/nhatminhle/cofoja) framework allows a developer to add contracts to their methods.
These contracts are formulated as normal Java expressions in double quotes (`“like this”`).
Inside the contracts you can reference the method arguments and class members.

Here is an example for specifying the class invariant `s != null` for a class `CharacterSet`:

```java
@Invariant("s != null")
public class CharacterSet {
    public CharacterSet() {
        s = new StringBuffer();
    }
...
```

### Exercise 1: Fibonacci and pre-conditions
In [`RecursiveFibonacci.java`](src/main/java/ch/epfl/sweng/contracts/RecursiveFibonacci.java) we provide an implementation of a recursive Fibonacci number generator.
Fibonacci numbers are generated by a function defined on non-negative numbers, hence the contract: `0 <= n` and `0 <= result`;

[`RecursiveFibonacciTest.java`](src/test/java/ch/epfl/sweng/contracts/RecursiveFibonacciTest.java) contains two junit tests.
`fibOnNegativeFails` checks that Cofoja indeed protects the function from incorrect calls (i.e., which violate the pre-condition).
`fibOf4` tests the corectness of the Fibonacci sequence computation.

Run the tests as usual, with `./gradlew test`

But, wait a minute! The second test fails.  It turns out that the pre-condition is violated.
Check your `build/reports/tests/test/index.html` report file to see the stack trace that points to the line that violated the pre-condition.

Fix the code.

### Exercise 2: Dynamic Vector

Let's get a bit more sophisticated now.

In [`SwengVector.java`](src/main/java/ch/epfl/sweng/contracts/SwengVector.java) you can find an example of a Java `interface` augmented with a contract.

The `add` post-condition contains two assertions:

1. The newly added element stays in the vector
2. All the old elements remain in the vector (the Javadoc comment provides some more details on how we formulate this)

[`SwengArrayList`](src/main/java/ch/epfl/sweng/contracts/SwengArrayList.java) implements the `SwengVector` interface, but contains two bugs. The interface post-condition can catch both bugs, but we need to run the code such that it exercises the buggy behavior, because Cofoja checks the contracts _dynamically_, i.e., during execution, as opposed to _statically_ during compilation.

So [`SwengVectorTests`](src/test/java/ch/epfl/sweng/contracts/SwengVectorTests.java) contains a test that fails because of the bugs.

Use the Gradle report to find the failing checks. Use Cofoja contracts to confirm your assumptions about the code.

*Hint:* you may want to add an `"old(toList()).stream().allMatch(this::contains)"` post-condition to the `expandArray` method.

### Exercise 3: Fraction

The following class implements rational numbers. Unfortunately, the `toInt()` method sometimes throws an `ArithmeticException`.
Add an invariant and a constructor pre-condition to make sure `toInt()` never throws an exception.
To do that, replace `<write your code here...>` with valid expressions.

You can copy this snippet into a file `src/main/java/ch/epfl/sweng/contracts/Fraction.java` and add some tests to [`src/test/java/ch/epfl/sweng/contracts/FractionTests.java`](src/test/java/ch/epfl/sweng/contracts/FractionTests.java) to compile and test it.

```java
@Invariant("<write your code here(a)>")
public class Fraction {
  private int n;
  private int d;

  @Requires("<write your code here(b)>")
  public Fraction(int n, int d) {
    this.n = n;
    this.d = d;
  }

  public int toInt() {
    return n/d;
  }
}

```


### Exercise 4: Stack

The following implementation of a stack may sometimes throw `java.lang.ArrayIndexOutOfBoundsException` exceptions. To solve this exercise, please provide in the code below the class invariant, pre-conditions, and post-conditions for methods `pop` and `push` that prevent these exceptions from arising, and thus make the code correct. You should provide replacements for the 5 placeholders `“<write your code here(a/b/c/d/e)>”`. You are not permitted to reference private class members in the pre- and post-conditions.

You can copy this snippet into a file `src/main/java/ch/epfl/sweng/contracts/SwengStack.java` and add some tests to [`src/test/java/ch/epfl/sweng/contracts/SwengStackTests.java`](src/test/java/ch/epfl/sweng/contracts/SwengStackTests.java) to compile and test it.

```java
@Invariant("<write your code here(a)>")
class SwengStack {
    private int capacity;
    private int numberOfElements;
    private int[] contents;

    public SwengStack(int capacity) {
        this.capacity = capacity;
        numberOfElements = 0;
        contents = new int[capacity];
    }

    public boolean isEmpty() {
        return numberOfElements == 0;
    }

    public boolean isFull() {
        return numberOfElements == capacity;
    }

    @Requires("<write your code here(b)>")
    @Ensures("<write your code here(c)>")
    public int pop() {
        numberOfElements -= 1;
        return contents[numberOfElements];
    }

    @Requires("<write your code here(d)>")
    @Ensures("<write your code here(e)>")
    public void push(int x) {
        contents[numberOfElements] = x;
        numberOfElements += 1;
    }
}

```
